% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/validation_broadcasted_sparsetenreg.R
\name{validation_broadcasted_sparsetenreg}
\alias{validation_broadcasted_sparsetenreg}
\title{Tune parameters through validation method}
\usage{
validation_broadcasted_sparsetenreg(
  R,
  alpha,
  lambda,
  X_train,
  y_train,
  X_vali,
  y_vali,
  X_test,
  y_test,
  num_knots = 5,
  order = 4
)
}
\arguments{
\item{R}{grids of the rank used in the algorithm}

\item{alpha}{grids of \eqn{\lambda_2} used in the algorithm}

\item{lambda}{grids of \eqn{\lambda_1} used in the algorithm}

\item{X_train}{the training input}

\item{y_train}{the training output}

\item{X_vali}{the validation input}

\item{y_vali}{the validation output}

\item{X_test}{the test input (if have)}

\item{y_test}{the test output (if have)}

\item{num_knots}{num of knots used for the spline basis}

\item{order}{the order of spline basis}
}
\value{
\item{MSE_vali}{validation error}
\item{MSE_pre}{prediction error}
\item{BB}{the estimated coefficient tensor (in tensor form)}
\item{bb}{the estimated intercept term}
\item{betabig}{list of estimated tensor in CP components form}
\item{BBbig_nonlinear}{list of estimated tensor in tensor form}
\item{b_validation_test_lambda_R_nonlinear}{each row is one fitting on specific tuning parameters.
And, 1st column: intercept; 2nd column:
validation error; 3rd: prediction error; 4th: rank used in the algorithm;
5th: \eqn{\lambda_2} used in the algorithm; 6th: \eqn{\lambda_1} used in the algorithm}
\item{others}{used for the package developer}
}
\description{
Tune parameters through validation method
}
\examples{
data("X_horse")
BB <- X_horse

set.seed(2019)

# sample size of the training and test set
n_train <- 400
n_test <- 100

# signal level
signal_level = 0.5


# generate the training data
X_train = array(runif(prod(c(dim(BB), n_train)), 0, 1), c(dim(BB), n_train))
# broadcated procedure
BroX_train = X_train + 0.6 * sin(2 * pi * (X_train - 0.5)^2)
y_train = 1 + crossprod(matrix(BroX_train, c(prod(dim(BB)), n_train)), as.vector(BB)) + signal_level * rnorm(n_train)

# generate the test data
X_test = array(runif(prod(c(dim(BB), n_test)), 0, 1), c(dim(BB), n_test))
BroX_test = X_test + 0.6 * sin(2 * pi * (X_test - 0.5)^2)
y_test = 1 + crossprod(matrix(BroX_test, c(prod(dim(BB)), n_test)), as.vector(BB)) + signal_level * rnorm(n_test)


set.seed(1224) # used for validation method
n_vali = 0.25 * n_train
# generate the validation data
X_vali = array(runif(prod(c(dim(BB), n_vali)), 0, 1), c(dim(BB), n_test))
BroX_vali = X_vali + 0.6 * sin(2 * pi * (X_vali - 0.5)^2)
y_vali = 1 + crossprod(matrix(BroX_vali, c(prod(dim(BB)), n_vali)), as.vector(BB)) + signal_level * rnorm(n_vali)


R=c(1,2,3,4,5)
alpha=c(0,0.5,1)
lambda=c(0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000)
# when running, just remove "#". It takes some time.
#res_valiandtest <- validation_broadcasted_sparsetenreg(R,alpha,lambda,X_train,y_train,X_vali,y_vali,X_test,y_test, num_knots=5, order=4)
}
\references{
Y. Zhou, R. K. W. Wong and K. He. Broadcasted Nonparametric Tensor Regression
}
\seealso{
broadcasted_sparsetenreg, sequential_warmstart
}
